diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c
index 38a7586b..0e856ff6 100644
--- a/drivers/mmc/core/block.c
+++ b/drivers/mmc/core/block.c
@@ -1237,7 +1237,7 @@ static void mmc_blk_issue_flush(struct mmc_queue *mq, struct request *req)
 	struct mmc_card *card = md->queue.card;
 	int ret = 0;
 
-	ret = mmc_flush_cache(card);
+	ret = mmc_flush_cache(card, false);
 	blk_mq_end_request(req, ret ? BLK_STS_IOERR : BLK_STS_OK);
 }
 
diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c
index 6f8ebd6c..cc9cb5ce 100644
--- a/drivers/mmc/core/mmc.c
+++ b/drivers/mmc/core/mmc.c
@@ -1985,7 +1985,7 @@ static int _mmc_suspend(struct mmc_host *host, bool is_suspend)
 			goto out;
 	}
 
-	err = mmc_flush_cache(host->card);
+	err = mmc_flush_cache(host->card, false);
 	if (err)
 		goto out;
 
@@ -2125,7 +2125,7 @@ static int mmc_reset(struct mmc_host *host)
 	 * In the case of recovery, we can't expect flushing the cache to work
 	 * always, but we have a go and ignore errors.
 	 */
-	mmc_flush_cache(host->card);
+	mmc_flush_cache(host->card, true);
 
 	if ((host->caps & MMC_CAP_HW_RESET) && host->ops->hw_reset &&
 	     mmc_can_reset(card)) {
diff --git a/drivers/mmc/core/mmc_ops.c b/drivers/mmc/core/mmc_ops.c
index 42d6aa89..957e8a20 100644
--- a/drivers/mmc/core/mmc_ops.c
+++ b/drivers/mmc/core/mmc_ops.c
@@ -1005,18 +1005,23 @@ void mmc_start_bkops(struct mmc_card *card, bool from_exception)
 }
 EXPORT_SYMBOL(mmc_start_bkops);
 
-/*
- * Flush the cache to the non-volatile storage.
+/**
+ * mmc_flush_cache - Flush (write) the cache to the non-volatile storage.
+ * @card: the MMC card to flush
+ * @ignore_err: Ignore any associated errors, also skips polling for the
+ *                command status in case card is in bad state
  */
-int mmc_flush_cache(struct mmc_card *card)
+int mmc_flush_cache(struct mmc_card *card, bool ignore_err )
 {
 	int err = 0;
+  bool use_busy_signal = !ignore_err;
 
 	if (mmc_card_mmc(card) &&
 			(card->ext_csd.cache_size > 0) &&
 			(card->ext_csd.cache_ctrl & 1)) {
-		err = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
-				EXT_CSD_FLUSH_CACHE, 1, 0);
+		err = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,
+                       EXT_CSD_FLUSH_CACHE, 1, 0, 0, use_busy_signal,
+                       true, false);
 		if (err)
 			pr_err("%s: cache flush error %d\n",
 					mmc_hostname(card->host), err);
diff --git a/drivers/mmc/core/mmc_ops.h b/drivers/mmc/core/mmc_ops.h
index a1390d48..47cdf920 100644
--- a/drivers/mmc/core/mmc_ops.h
+++ b/drivers/mmc/core/mmc_ops.h
@@ -42,7 +42,7 @@ int mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,
 		unsigned int timeout_ms);
 int mmc_stop_bkops(struct mmc_card *card);
 void mmc_start_bkops(struct mmc_card *card, bool from_exception);
-int mmc_flush_cache(struct mmc_card *card);
+int mmc_flush_cache(struct mmc_card *card, bool ignore_err);
 int mmc_cmdq_enable(struct mmc_card *card);
 int mmc_cmdq_disable(struct mmc_card *card);
 
